# this全面解析

-   调用位置
    -   调用位置决定了this的绑定
    -   调用栈决定调用位置，调用位置当前正在执行的函数的前一个调用。  

## 绑定规则

-   调用位置如何决定this的绑定对象，先找到调用位置，然后在应用下面4条规则，看符合哪一条

    1.  默认绑定：独立函数调用，可以把这条规则看作是无法应用其他规则时的默认规则

        ```javascript
          function fun(){
            console.log(this.a);
          }
          var a=2;
          fun();
        ```

        _在严格模式中,这个this并不会绑定到全局,而是绑定为undefind.通常来说,严格模式和非严格模式不会混合使用,有时候你可能会用到第三方库,可能别人的严格程度和你的不一样,一定要注意这类细节_

    2.  隐藏绑定:调用位置是否有上下为文(例如:obj.foo();obj为上下文),调用位置会使用上下文来绑定this,或者说在函数执行的时候,上下文持有这个函数或者变量.

        ```javascript
          function foo(){console.log(this.name)};
          var obj = {foo:foo}
          obj.foo();
        ```

        -   隐式丢失
            ```javascript
              var obj ={
                name:'kim',
                foo:function(bar){
                  // (bar.bind(this))();
                  bar();//window
                  // var _bar = bar;
                  // _bar();
                }
              };
              obj.foo(function(){
                console.log(this);
              });
              // 这段代码说明,回调函数无论函数
              //在何处定义,在调用位置若是无任
              //何修饰(上下文),则使用默认绑定规则
            ```
            _一个最常见的丢失是,被隐式绑定的this会丢失,应用了默认绑定,从而把this绑定在了全局的作用域上,取决于是否是严格模式._

    3.  显式绑定 使用fn.call(obj,par)&fn.apply(obj,[array]); call的par参数就是fn所需要的参数,apply的[array]数组参数的值会赋值给fn的arguments(即arguments和数组值相等);

      - 硬绑定

        ```javascript
              function foo() {
                console.log( this.a );
              }
              var obj = {
                a:2
              };
              var bar = function() {
                foo.call( obj );
              };
              bar(); // 2
              setTimeout( bar, 100 ); // 2
                // 硬绑定的bar不可能再修改它的this
              bar.call( window ); // 2
        ```

        *在bar内部手动的绑定obj到foo,无论外部怎么调用bar,它总会手动在obj上调用foo*
      - 另一种方式(巧)
        ```javascript
        function foo(something) {
          console.log( this.a, something );
          return this.a + something;
        }
        // 简单的辅助绑定函数
        function bind(fn, obj) {
          return function() {
            return fn.apply( obj, arguments );
          };
        }
        var obj = {
          a:2
        };
        var bar = bind( foo, obj ); //此时返回一个匿名函数,并没有执行fn,但是参数已经传递进去
        var b = bar( [3,5] ); // 2 3  真正的调用,通过绑定的obj调用fn
        console.log( b ); // 5
        // es5 的 bind() 方法原理
        ```

    4.
