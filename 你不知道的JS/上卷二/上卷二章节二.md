# this全面解析
- 调用位置
  - 调用位置决定了this的绑定
  - 调用栈决定调用位置，调用位置当前正在执行的函数的前一个调用。  

## 绑定规则
- 调用位置如何决定this的绑定对象，先找到调用位置，然后在应用下面4条规则，看符合哪一条
  1. 默认绑定：独立函数调用，可以把这条规则看作是无法应用其他规则时的默认规则
    ```javascript
      function fun(){
        console.log(this.a);
      }
      var a=2;
      fun();
    ```

    *在严格模式中,这个this并不会绑定到全局,而是绑定为undefind.通常来说,严格模式和非严格模式不会混合使用,有时候你可能会用到第三方库,可能别人的严格程度和你的不一样,一定要注意这类细节*

  2. 隐藏绑定:调用位置是否有上下为文(例如:obj.foo();obj为上下文),调用位置会使用上下文来绑定this,或者说在函数执行的时候,上下文持有这个函数或者变量.
    ```javascript
      function foo(){console.log(this.name)};
      var obj = {foo:foo}
      obj.foo();
    ```
    - 隐式丢失
      ```javascript
        var obj ={
          name:'kim',
          foo:function(bar){
            // (bar.bind(this))();
            bar();//window
            // var _bar = bar;
            // _bar();
          }
        };
        obj.foo(function(){
          console.log(this);
        });
        // 这段代码说明,回调函数无论函数在何处定义,在调用位置若是无任何修饰(上下文),则使用默认绑定规则
      ```
      _一个最常见的丢失是,被隐式绑定的this会丢失,应用了默认绑定,从而把this绑定在了全局的作用域上,取决于是否是严格模式._

  3. 显式绑定 使用call(obj,par)&apply(obj,[array]);
    - 
