# 传统编译语言的流程

- 分词/词法分析

  > 这个过程会奖由字符组成的字符串分解成有意义的代码块,这次代码块被成为词法单元(token)

- 解析/语法分析

> 这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法 结构的树。这个树被称为"抽象语法树"（Abstract Syntax Tree，AST）。 var a = 2; 的抽象语法树中可能会有一个叫作VariableDeclaration 的顶级节点，接下 来是一个叫作Identifier（它的值是a）的子节点，以及一个叫作AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫作NumericLiteral（它的值是2）的子 节点

- 代码生成

> 将AST 转换为可执行代码的过程称被称为代码生成.抛开具体细节，简单来说就是有某种方法可以将var a = 2; 的AST 转化为一组机器指令，用来创建一个叫作a 的变量（包括分配内存等），并将一个值储存在a 中。

## javascript编译过程

- javascript与其他的编译语言不同

  > 对于javascript,大部分情况下编译发生在代码执行前的几微秒的时间内.

# 编译3剑侠

1. 引擎

2. 编译器

3. 作用域

## LHS & RSH (引擎查询方式)

- LSH:赋值操作的目标是谁 (目标:容器变量本身)
- RSH:谁是赋值操作的源头 (源:查找某一个值)

  > for example

  > > `function foo(a){console.log(a)} foo(2)`

  > > foo():RSH 找到foo的值(函数类型) 里面隐藏着a=2这个赋值操作,对a是LSH,因为要找到a容器

  > > _你可能会倾向于将函数声明function foo(a) {... 概念化为普通的变量声明和赋值，比如var foo、foo ＝ function(a) {...。如果这样理解的话，这个函数声明将需要进行LHS 查询。然而还有一个重要的细微差别，编译器可以在代码生成的同时处理声明和值 的定义，比如在引擎执行代码时，并不会有线程专门用来将一个函数值"分 配给"foo。因此，将函数声明理解成前面讨论的LHS 查询和赋值的形式并 不合适。_

## 引擎与作用域的对话

- `function foo(a) { console.log( a ); // 2 } foo( 2 );`

  > 引擎：我说作用域，我需要为foo 进行RHS 引用。你见过它吗？<br>
  > 作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。<br>
  > 引擎：哥们太够意思了！好吧，我来执行一下foo。<br>
  > 引擎：作用域，还有个事儿。我需要为a 进行LHS 引用，这个你见过吗？<br>
  > 作用域：这个也见过，编译器最近把它声名为foo 的一个形式参数了，拿去吧。<br>
  > 引擎：大恩不言谢，你总是这么棒。现在我要把2 赋值给a。<br>
  > 引擎：哥们，不好意思又来打扰你。我要为console 进行RHS 引用，你见过它吗？<br>
  > 作用域：咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。 给你。<br>
  > 引擎：么么哒。我得看看这里面是不是有log(..)。太好了，找到了，是一个函数。<br>
  > 引擎：哥们，能帮我再找一下对a 的RHS 引用吗？虽然我记得它，但想再确认一次。<br>
  > 作用域：放心吧，这个变量没有变动过，拿走，不谢。 引擎：真棒。我来把a 的值，也就是2，传递进log(..)。

## 异常

- 正常模式

  > 在全局区域都找不到变量的时候会自动创建一个全局变量

- 严格模式(ES5)

  > 在全局区域找不到变量的时候会报错

_ReferenceError 同作用域判别失败相关，而TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。_

## 小结

- 作用域是一套规则,用于确定在何处以及如何查找变量(标识符),如果查找的目的是对变量进行赋值,那么就会使用LHS查询;如果目的是获取变量的值,就会使用RHS查询.

- 赋值操作符导致LHS查询. =操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作.

- javascript引擎首先会在代码执行前对其进行编译,在这个过程中,像var a=2 这样的声明会被分解成两个独立的步骤:

  > 1.首先,var a在其作用域中声明新变量,这会是最开始的阶段,也就是好代码执行前进行 2.接下来 a=2会查询(LHS查询) 变量a并对其赋值

- 两种查询方式在当前作用域找不到都会向上层作用域查找 当找到全局作用域时,无论有没有找到所需要的标识符他们都会停止查找

- 不成功的RHS引用会抛出 referenceError异常 不成功的LHS引用会导致自动隐式地创建一个全局变量(非严格模式),该变量使用LHS引用的目标作为标识符,或者抛出referenceError异常(严格模式)
